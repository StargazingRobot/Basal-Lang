
summary :
    # - no semi-colon
    # - being statement always implied (changes from pascal)
    # +-> end statement always required
    # - var and bin? keyword to declare variables ( int and bool )
    # - [] operator to declare array ? or type array[size] ? ex: var array[10] t
    # - func to declare functions


// highlight uppercase : syn match preproc "[A-Z]"
// highlight keywords  : syn match keyword "var\|bin\|set\|array\|string\|str"
// highlight comments  : syn match comment "#.*$" 


# 2numbers : 1 integer part, 1 decimal part
# hence every var would be int and float 
# float should not be encoded on 16 bits.

var a = 123     # declare une variable
bin b = false   # declare une variable binaire (boolean)


# set is a good idea, could be used to store multiple return values
set s = { var, var, var, bin, bin } # declaration
s = { 1, 2, 3, true, true }         # initialization 

var array[10] t1 = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
bin array[8] t2 = { 0, 1, false, 0, 0, 0, true, 1 }

# this approach is not ideal : lot of hidden behaviors with implicit conversion
# other possibility -> int and bin are implicitly convertible ( ex: false = 0 and true otherwise like C )
var a # automatically initialized to 0 | false
array[5] t = { 1, 2, 3, false, vrai } # perhaps not very coherent

# Fonction recursive affichant la suite de fibonacci
FONCTION FIBO( var a, var b, var c )
    AFFICHER( b )
    SI c < 0 ALORS              # Condition de sortie
        FIBO( b, a + b, c - 1)  # Appel recursif de la fonction
    FIN
FIN

# English version
FUNCTION FIBO( var a, var b, var c )
    DISP( b )
    IF c < 0 THEN
        FIBO( b, a + b, c - 1)
    END
END

# sort array function
FONCTION SORT( var array& t ) # pass by reference
    var taille = TAILLE( t )
    POUR var i=0 JUSQUA taille FAIRE
        var min = 65535 # init at maximum value
        var ind = 0
        POUR var j=i JUSQUA taille FAIRE
            SI t[j] < min ALORS
                min = t[j]
                ind = j
            FIN 
        FIN
        SI ind != 0 ALORS # swap
            t[ind] = t[i]
            t[i] = min
        FIN
    FIN
FIN

# sort 3 value in ascending order
FUNCTION test( var a, var b, var c )
    var tmp 
    IF a > b THEN
        tmp = a
        a = b
        b = tmp
    FIN
    IF c < a THEN # c is the smallest
        tmp = a 
        a = c
        c = tmp
    ELSE IF c < b THEN # c is the second smallest
        tmp = b
        b = c
        c = tmp
    FIN

FIN


# possibilite pour exprimer le type de renvoi d'une fonction

FONCTION F( var& x ) var
   RENVOYER 14x^2 -7x + 3 
FIN

FONCTION CARRE( var x ) var
    RENVOYER x^2
FIN

# returns allow for direct initialization
var a = F( 3 ) % 2



